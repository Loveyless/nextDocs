import re

# Read the original English file
with open('D:/code/mycode/next.js-canary/docs/01-app/01-getting-started/03-layouts-and-pages.mdx.en', 'r', encoding='utf-8') as f:
    content = f.read()

# Translate front matter
content = re.sub(r'title: Layouts and Pages', 'title: 布局和页面', content)
content = re.sub(r'description: Learn how to create your first pages and layouts, and link between them with the Link component.', 'description: 学习如何创建你的第一个页面和布局，以及如何使用 Link 组件在它们之间进行链接。', content)
content = re.sub(r'title: API Reference', 'title: API 参考', content)
content = re.sub(r'description: Learn more about the features mentioned in this page by reading the API Reference.', 'description: 通过阅读 API 参考了解更多关于本页面提到的功能。', content)

# Translate main content
content = re.sub(r'Next\.js uses \*\*file-system based routing\*\*', 'Next.js 使用**基于文件系统的路由**', content)
content = re.sub(r'This page will guide you through how to create layouts and pages, and link between them\.', '本页面将指导你如何创建布局和页面，以及在它们之间进行链接。', content)
content = re.sub(r'## Creating a page', '## 创建页面', content)
content = re.sub(r'A \*\*page\*\* is UI that is rendered on a specific route\.', '**页面**是在特定路由上渲染的 UI。', content)
content = re.sub(r'To create a page, add a \[\`page\` file\]\(/docs/app/api-reference/file-conventions/page\) inside the \`app\` directory and default export a React component\.', '要创建页面，在 `app` 目录内添加一个 [`page` 文件](/docs/app/api-reference/file-conventions/page) 并默认导出一个 React 组件。', content)
content = re.sub(r'For example, to create an index page \(\`\/\`\):', '例如，要创建索引页面（`/`）：', content)
content = re.sub(r'alt=\"page\.js special file\"', 'alt="page.js 特殊文件"', content)
content = re.sub(r'## Creating a layout', '## 创建布局', content)
content = re.sub(r'A layout is UI that is \*\*shared\*\* between multiple pages\.', '布局是在多个页面之间**共享**的 UI。', content)
content = re.sub(r'On navigation, layouts preserve state, remain interactive, and do not rerender\.', '在导航时，布局保持状态，保持交互性，并且不会重新渲染。', content)
content = re.sub(r'You can define a layout by default exporting a React component from a \[\`layout\` file\]\(/docs/app/api-reference/file-conventions/layout\)\.', '你可以通过从 [`layout` 文件](/docs/app/api-reference/file-conventions/layout) 默认导出 React 组件来定义布局。', content)
content = re.sub(r'The component should accept a \`children\` prop which can be a page or another \[layout\]\(#nesting-layouts\)\.', '该组件应该接受一个 `children` prop，它可以是一个页面或另一个[布局](#嵌套布局)。', content)
content = re.sub(r'For example, to create a layout that accepts your index page as child, add a \`layout\` file inside the \`app\` directory:', '例如，要创建一个接受索引页面作为子项的布局，在 `app` 目录内添加一个 `layout` 文件：', content)
content = re.sub(r'alt=\"layout\.js special file\"', 'alt="layout.js 特殊文件"', content)
content = re.sub(r'The layout above is called a \[root layout\]\(/docs/app/api-reference/file-conventions/layout#root-layout\)', '上面的布局被称为[根布局](/docs/app/api-reference/file-conventions/layout#根布局)', content)
content = re.sub(r'The root layout is \*\*required\*\* and must contain \`html\` and \`body\` tags\.', '根布局是**必需的**，并且必须包含 `html` 和 `body` 标签。', content)
content = re.sub(r'## Creating a nested route', '## 创建嵌套路由', content)
content = re.sub(r'A nested route is a route composed of multiple URL segments\.', '嵌套路由是由多个 URL 段组成的路由。', content)
content = re.sub(r'For example, the \`\/blog\/\[slug\]\` route is composed of three segments:', '例如，`/blog/[slug]` 路由由三个段组成：', content)
content = re.sub(r'- \`\/\` \(Root Segment\)', '- `/`（根段）', content)
content = re.sub(r'- \`blog\` \(Segment\)', '- `blog`（段）', content)
content = re.sub(r'- \`\[slug\]\` \(Leaf Segment\)', '- `[slug]`（叶段）', content)
content = re.sub(r'In Next\.js:', '在 Next.js 中：', content)
content = re.sub(r'- \*\*Folders\*\* are used to define the route segments that map to URL segments\.', '- **文件夹**用于定义映射到 URL 段的路由段。', content)
content = re.sub(r'- \*\*Files\*\* \(like \`page\` and \`layout\`\) are used to create UI that is shown for a segment\.', '- **文件**（如 `page` 和 `layout`）用于创建显示段的 UI。', content)
content = re.sub(r'To create nested routes, you can nest folders inside each other\.', '要创建嵌套路由，你可以相互嵌套文件夹。', content)
content = re.sub(r'For example, to add a route for \`\/blog\`, create a folder called \`blog\` in the \`app\` directory\.', '例如，要为 `/blog` 添加路由，在 `app` 目录中创建一个名为 `blog` 的文件夹。', content)
content = re.sub(r'Then, to make \`\/blog\` publicly accessible, add a \`page\.tsx\` file:', '然后，要使 `/blog` 公开可访问，添加一个 `page.tsx` 文件：', content)
content = re.sub(r'alt=\"File hierarchy showing blog folder and a page\.js file\"', 'alt="显示 blog 文件夹和 page.js 文件的文件层次结构"', content)
content = re.sub(r'// Dummy imports', '// 虚拟导入', content)
content = re.sub(r'You can continue nesting folders to create nested routes\.', '你可以继续嵌套文件夹来创建嵌套路由。', content)
content = re.sub(r'For example, to create a route for a specific blog post, create a new \`\[slug\]\` folder inside \`blog\` and add a \`page\` file:', '例如，要为特定的博客文章创建路由，在 `blog` 内创建一个新的 `[slug]` 文件夹并添加一个 `page` 文件：', content)
content = re.sub(r'alt=\"File hierarchy showing blog folder with a nested slug folder and a page\.js file\"', 'alt="显示 blog 文件夹中嵌套 slug 文件夹和 page.js 文件的文件层次结构"', content)
content = re.sub(r'Hello, Blog Post Page!', '你好，博客文章页面！', content)
content = re.sub(r'Wrapping a folder name in square brackets \(e\.g\. \`\[slug\]\`\) creates a \[dynamic route segment\]\(/docs/app/api-reference/file-conventions/dynamic-routes\)', '将文件夹名称用方括号括起来（例如 `[slug]`）会创建一个[动态路由段](/docs/app/api-reference/file-conventions/dynamic-routes)', content)
content = re.sub(r'which is used to generate multiple pages from data\. e\.g\. blog posts, product pages, etc\.', '用于从数据生成多个页面。例如博客文章、产品页面等。', content)
content = re.sub(r'## Nesting layouts', '## 嵌套布局', content)
content = re.sub(r'By default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their \`children\` prop\.', '默认情况下，文件夹层次结构中的布局也是嵌套的，这意味着它们通过它们的 `children` prop 包装子布局。', content)
content = re.sub(r'You can nest layouts by adding \`layout\` inside specific route segments \(folders\)\.', '你可以通过在特定路由段（文件夹）内添加 `layout` 来嵌套布局。', content)
content = re.sub(r'For example, to create a layout for the \`\/blog\` route, add a new \`layout\` file inside the \`blog\` folder\.', '例如，要为 `/blog` 路由创建布局，在 `blog` 文件夹内添加一个新的 `layout` 文件。', content)
content = re.sub(r'alt=\"File hierarchy showing root layout wrapping the blog layout\"', 'alt="显示根布局包装博客布局的文件层次结构"', content)
content = re.sub(r'If you were to combine the two layouts above, the root layout \(`app/layout.js`\) would wrap the blog layout \(`app/blog/layout.js`\), which would wrap the blog \(`app/blog/page.js`\) and blog post page \(`app/blog/\[slug\]/page.js`\)\.', '如果你将上面两个布局组合起来，根布局（`app/layout.js`）会包装博客布局（`app/blog/layout.js`），后者会包装博客（`app/blog/page.js`）和博客文章页面（`app/blog/[slug]/page.js`）。', content)
content = re.sub(r'## Creating a dynamic segment', '## 创建动态段', content)
content = re.sub(r'\[Dynamic segments\]\(/docs/app/api-reference/file-conventions/dynamic-routes\) allow you to create routes that are generated from data\.', '[动态段](/docs/app/api-reference/file-conventions/dynamic-routes)允许你创建从数据生成的路由。', content)
content = re.sub(r'For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data\.', '例如，你可以创建动态段来根据博客文章数据生成路由，而不是为每个单独的博客文章手动创建路由。', content)
content = re.sub(r'To create a dynamic segment, wrap the segment \(folder\) name in square brackets: \`\[segmentName\]\`\.', '要创建动态段，将段（文件夹）名称用方括号括起来：`[segmentName]`。', content)
content = re.sub(r'For example, in the \`app/blog/\[slug\]/page\.tsx\` route, the \`\[slug\]\` is the dynamic segment\.', '例如，在 `app/blog/[slug]/page.tsx` 路由中，`[slug]` 是动态段。', content)
content = re.sub(r'Learn more about \[Dynamic Segments\]\(/docs/app/api-reference/file-conventions/dynamic-routes\)', '了解更多关于[动态段](/docs/app/api-reference/file-conventions/dynamic-routes)', content)
content = re.sub(r'and the \[\`params\`\]\(/docs/app/api-reference/file-conventions/page#params-optional\) props\.', '和 [`params`](/docs/app/api-reference/file-conventions/page#params-可选) props 的信息。', content)
content = re.sub(r'Nested \[layouts within Dynamic Segments\]\(/docs/app/api-reference/file-conventions/layout#params-optional\), can also access the \`params\` props\.', '动态段内的[嵌套布局](/docs/app/api-reference/file-conventions/layout#params-可选)也可以访问 `params` props。', content)
content = re.sub(r'## Rendering with search params', '## 使用搜索参数渲染', content)
content = re.sub(r'In a Server Component \*\*page\*\*, you can access search parameters using the \[\`searchParams\`\]\(/docs/app/api-reference/file-conventions/page#searchparams-optional\) prop:', '在服务器组件**页面**中，你可以使用 [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-可选) prop 访问搜索参数：', content)
content = re.sub(r'Using \`searchParams\` opts your page into \[\*\*dynamic rendering\*\*\]\(/docs/app/guides/caching#dynamic-rendering\)', '使用 `searchParams` 会使你的页面选择[**动态渲染**](/docs/app/guides/caching#动态渲染)', content)
content = re.sub(r'because it requires an incoming request to read the search parameters from\.', '因为它需要传入请求来读取搜索参数。', content)
content = re.sub(r'Client Components can read search params using the \[\`useSearchParams\`\]\(/docs/app/api-reference/functions/use-search-params\) hook\.', '客户端组件可以使用 [`useSearchParams`](/docs/app/api-reference/functions/use-search-params) hook 读取搜索参数。', content)
content = re.sub(r'Learn more about \`useSearchParams\` in \[statically rendered\]\(/docs/app/api-reference/functions/use-search-params#static-rendering\)', '了解更多关于 `useSearchParams` 在[静态渲染](/docs/app/api-reference/functions/use-search-params#静态渲染)', content)
content = re.sub(r'and \[dynamically rendered\]\(/docs/app/api-reference/functions/use-search-params#dynamic-rendering\) routes\.', '和[动态渲染](/docs/app/api-reference/functions/use-search-params#动态渲染)路由中的信息。', content)
content = re.sub(r'### What to use and when', '### 何时使用什么', content)
content = re.sub(r'- Use the \`searchParams\` prop when you need search parameters to \*\*load data for the page\*\* \(e\.g\. pagination, filtering from a database\)\.', '- 当你需要搜索参数来**为页面加载数据**时（例如分页、从数据库过滤），使用 `searchParams` prop。', content)
content = re.sub(r'- Use \`useSearchParams\` when search parameters are used \*\*only on the client\*\* \(e\.g\. filtering a list already loaded via props\)\.', '- 当搜索参数**仅在客户端**使用时（例如过滤已经通过 props 加载的列表），使用 `useSearchParams`。', content)
content = re.sub(r'- As a small optimization, you can use \`new URLSearchParams\(window\.location\.search\)\` in \*\*callbacks or event handlers\*\* to read search params without triggering re-renders\.', '- 作为一个小优化，你可以在**回调或事件处理程序**中使用 `new URLSearchParams(window.location.search)` 来读取搜索参数，而不会触发重新渲染。', content)
content = re.sub(r'## Linking between pages', '## 页面间链接', content)
content = re.sub(r'You can use the \[\`\u003cLink\u003e\` component\]\(/docs/app/api-reference/components/link\) to navigate between routes\.', '你可以使用 [`<Link>` 组件](/docs/app/api-reference/components/link) 在路由之间导航。', content)
content = re.sub(r'\u003cLink\u003e is a built-in Next\.js component that extends the HTML \u003ca\u003e tag to provide \[prefetching\]\(/docs/app/getting-started/linking-and-navigating#prefetching\)', '`<Link>` 是一个内置的 Next.js 组件，它扩展了 HTML `<a>` 标签以提供[预取](/docs/app/getting-started/linking-and-navigating#预取)', content)
content = re.sub(r'and \[client-side navigation\]\(/docs/app/getting-started/linking-and-navigating#client-side-transitions\)\.', '和[客户端导航](/docs/app/getting-started/linking-and-navigating#客户端转换)。', content)
content = re.sub(r'For example, to generate a list of blog posts, import \u003cLink\u003e from \`next/link\` and pass a \`href\` prop to the component:', '例如，要生成博客文章列表，从 `next/link` 导入 `<Link>` 并将 `href` prop 传递给组件：', content)
content = re.sub(r'\u003e \*\*Good to know\*\*\: \u003cLink\u003e is the primary way to navigate between routes in Next\.js\. You can also use the \[\`useRouter\` hook\]\(/docs/app/api-reference/functions/use-router\) for more advanced navigation\.', '> **须知**：`<Link>` 是在 Next.js 中路由间导航的主要方式。你也可以使用 [`useRouter` hook](/docs/app/api-reference/functions/use-router) 进行更高级的导航。', content)
content = re.sub(r'## Route Props Helpers', '## 路由 Props 辅助类型', content)
content = re.sub(r'Next\.js exposes utility types that infer \`params\` and named slots from your route structure:', 'Next.js 暴露了从你的路由结构推断 `params` 和命名槽的实用类型：', content)
content = re.sub(r'- \[\*\*PageProps\*\*\]\(/docs/app/api-reference/file-conventions/page#page-props-helper\): Props for \`page\` components, including \`params\` and \`searchParams\`\.', '- [**PageProps**](/docs/app/api-reference/file-conventions/page#page-props-helper)：用于 `page` 组件的 props，包括 `params` 和 `searchParams`。', content)
content = re.sub(r'- \[\*\*LayoutProps\*\*\]\(/docs/app/api-reference/file-conventions/layout#layout-props-helper\): Props for \`layout\` components, including \`children\` and any named slots \(e\.g\. folders like \`@analytics\`\)\.', '- [**LayoutProps**](/docs/app/api-reference/file-conventions/layout#layout-props-helper)：用于 `layout` 组件的 props，包括 `children` 和任何命名槽（例如像 `@analytics` 这样的文件夹）。', content)
content = re.sub(r'These are globally available helpers, generated when running either \`next dev\`, \`next build\` or \[\`next typegen\`\]\(/docs/app/api-reference/cli/next#next-typegen-options\)\.', '这些是在运行 `next dev`、`next build` 或 [`next typegen`](/docs/app/api-reference/cli/next#next-typegen-options) 时生成的全局可用辅助类型。', content)
content = re.sub(r'Blog post:', '博客文章:', content)
content = re.sub(r'If you have app/dashboard/@analytics, it appears as a typed slot:', '如果你有 app/dashboard/@analytics，它会作为一个类型化的槽出现：', content)
content = re.sub(r'\u003e \*\*Good to know\*\*', '> **须知**', content)
content = re.sub(r'- Static routes resolve \`params\` to \`\{\}\`\.', '- 静态路由解析 `params` 为 `{}`。', content)
content = re.sub(r'- \`PageProps\`, \`LayoutProps\` are global helpers — no imports required\.', '- `PageProps`、`LayoutProps` 是全局辅助类型——无需导入。', content)
content = re.sub(r'- Types are generated during \`next dev\`, \`next build\` or \`next typegen\`\.', '- 类型在 `next dev`、`next build` 或 `next typegen` 期间生成。', content)

# Write the translated content
with open('D:/code/mycode/next.js-canary/docs/01-app/01-getting-started/03-layouts-and-pages.mdx', 'w', encoding='utf-8') as f:
    f.write(content)

print('Translation completed for 03-layouts-and-pages.mdx')